<!doctype html>
<html><head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>Test Area</title>

<style>
	body{ background-color: #100806;
			}
			
	canvas{ background-color: #100806;
			position: absolute;
			z-index:1;
	}
	body, html { width: 100%;
		height: 100%;
		border: 0px;
		padding: 0px;
		margin: 0px;
		cursor: pointer;
		cursor: hand; 
	}

	#glcanvas {
		width: 100%;
		height: 100%;
		vertical-align: bottom;
		display: block;
	}

	#hud {
		position: absolute;
		margin: 0 auto;		
		z-index: 2;
		font-family: Helvetica,Arial,sans-serif;
		font-size:10px;
		font-weight:normal;
		line-height:15px; 
		color: #fff;
		right: 10px;
		bottom: 7px;}

</style>

<script src="./js/raf_polyfill.js"></script> <!-- request animation frame -->

<script>
// create global variables
var gl = null,
	canvas = null,
	glProgram = null,
	renderShader= null,
	timestepShader= null,
	vertexShader = null;
	vbo = null;

// for counter
var elapsedTime = 0;
var frameCount = 0; 
var lastTime = new Date().getTime();	
var fps = 59;

// for uniforms	
var startTime = null,
	currentTime = null,
	xres = null,
	yres = null;


function initWebGL()
{
	canvas = document.getElementById("glcanvas");  
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	xres = canvas.width;
	yres = canvas.height;
	
	try{
		// get our webgl context
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");					
		checkCompatibility(gl);
	}catch(e){
	}

	if(gl){
		initShaders();

		var timestepProgram = createAndLinkProgram(gl, vertexShader, timestepShader);
		var renderProgram = createAndLinkProgram(gl, vertexShader, renderShader);

		//use program
		gl.useProgram(renderProgram);
		
		setupBuffers(gl, renderProgram);
		// uniforms
		renderProgram.timeUniform = gl.getUniformLocation(renderProgram, "iGlobalTime");
		renderProgram.resUniform = gl.getUniformLocation(renderProgram, "iResolution");
		gl.uniform2f(renderProgram.resUniform, xres, yres);
		gl.uniform1f(renderProgram.timeUniform, currentTime);
		
		//use program
		gl.useProgram(timestepProgram);
	
		setupBuffers(gl, timestepProgram);
		// uniforms
		timestepProgram.timeUniform = gl.getUniformLocation(timestepProgram, "iGlobalTime");
		timestepProgram.resUniform = gl.getUniformLocation(timestepProgram, "iResolution");
		gl.uniform2f(timestepProgram.resUniform, xres, yres);
		gl.uniform1f(timestepProgram.timeUniform, currentTime);
		

		var initial_state = getInitialState(); // manually populate initial texture state

		var texture1 = newTexture(gl, initial_state), // create texture with initial state 
			framebuffer1 = newFramebuffer(gl, texture1),
			texture2 = newTexture(gl, null), // blank texture
			framebuffer2 = newFramebuffer(gl, texture2);


		startTime = Date.now();

	gl.useProgram(timestepProgram);
	gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer1);
	var fb_status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
	if (fb_status != gl.FRAMEBUFFER_COMPLETE) {
		fail("Cannot render to framebuffer: " + fb_status);
	}
	
	// MAIN LOOP
		(function animLoop() {
			gl.useProgram(timestepProgram);
			for (var i=0; i<50; i++){
				gl.bindTexture(gl.TEXTURE_2D, [texture1, texture2][i % 2]);
				gl.bindFramebuffer(gl.FRAMEBUFFER, [framebuffer2, framebuffer1][i % 2]);
				drawScene();
			}

			gl.useProgram(renderProgram);
			gl.bindTexture(gl.TEXTURE_2D, texture1);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			drawScene();

			currentTime = (Date.now() - startTime) / 1000;
	
			// update uniforms		
			gl.uniform2f(renderProgram.resUniform, xres, yres);
			gl.uniform1f(renderProgram.timeUniform, currentTime);
		
			updateFPS();
			requestAnimationFrame(animLoop, canvas);

			// update window size
			resize(gl);
		} )();

	}

	
	else 
	{	
		alert( "Error: Your browser does not support WebGL." );
	}
}


function getInitialState() {
	var initState = new Float32Array(4 * xres * yres);
	for (var y=0; y<yres; y++) {
		for (var x=0; x<xres; x++) {

			var i = xres*y + x;
	
			var emissionRegion = (x%80 < 40 && x > 0 && y < yres && y > yres - 10);
				
			if (emissionRegion) {
				initState[4*i + 0] = 0.5;
				initState[4*i + 1] = 0.5;
			} else {
				initState[4*i + 0] = 1.0;
				initState[4*i + 1] = 0;
			}
		}
	}

	return initState;
}


// Create, initialise, and bind a new texture
function newTexture(gl, initial_state) {
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, xres, yres, 0, gl.RGBA, gl.FLOAT, initial_state);

	return texture;
}

function checkCompatibility(gl) {
	if (!gl) fail("WebGL is not supported");

	var float_texture_ext = gl.getExtension("OES_texture_float");
	if (!float_texture_ext) fail("Your browser does not support the WebGL extension OES_texture_float");
	window.float_texture_ext = float_texture_ext; // Hold onto it

	var max_texture_size = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	if (max_texture_size < 512) fail("Your browser only supports "+max_texture_size+"Ã—"+max_texture_size+" WebGL textures");
}

function newFramebuffer(gl, texture) {
	var fb = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

	return fb;
}

function initShaders()
{
	//get shader sources with XMLHttpRequestObject
	var fs_timestep_source = null,
		fs_render_source = null;
		vs_source = null;

	var xhr = new XMLHttpRequest();
	//synchronous request - false third parameter
	xhr.open('GET', './shaders/base.vs', false);
	//overriding the mime type is required 
	xhr.overrideMimeType('text/plain');
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			vs_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}  
	}

	xhr.open('GET', './shaders/render.fs', false); 
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			fs_render_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}
	}  

	xhr.open('GET', './shaders/timestep.fs', false); 
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			fs_timestep_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}
	}

	//compile shaders	
	vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
	timestepShader = makeShader(fs_timestep_source, gl.FRAGMENT_SHADER);
	renderShader = makeShader(fs_render_source, gl.FRAGMENT_SHADER);
}


function createAndLinkProgram(gl, vertex_shader, fragment_shader) 
{
	var prog = gl.createProgram();
	gl.attachShader(prog, vertex_shader);
	gl.attachShader(prog, fragment_shader);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		console.error("Failed to link program: " + gl.getProgramInfoLog(prog));  
		//fail("Failed to link program: " + gl.getProgramInfoLog(prog));
	}
	return prog;
}


function makeShader(src, type)
{
	//compile the vertex shader
	var shader = gl.createShader(type);
	gl.shaderSource(shader, src);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
	}
	return shader;
}


function getUniforms(gl, glProgram)
{
	glProgram.timeUniform = gl.getUniformLocation(glProgram, "iGlobalTime");
	glProgram.resUniform = gl.getUniformLocation(glProgram, "iResolution");
}


function setUniforms(gl, glProgram)
{
	gl.uniform1f(glProgram.timeUniform, currentTime);
	gl.uniform3f(glProgram.resUniform, 0.0, 1.0, 0.0);
}


function setupBuffers(gl, glProgram)
{
	var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     
										1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
	vbo = gl.createBuffer();
	gl.bindBuffer( gl.ARRAY_BUFFER, vbo );
	gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );		    
}


function drawScene()
{
	gl.vertexAttribPointer( gl, 2, gl.FLOAT, false, 0, 0);
	gl.enableVertexAttribArray( gl );
	gl.drawArrays(gl.TRIANGLES, 0, 6);
}


function setUniforms(glProgram){
	gl.uniform1f(glProgram.timeUniform, currentTime);
}


function resize(gl) {
	var realToCSSPixels = window.devicePixelRatio || 1;

	// Lookup the size the browser is displaying the canvas in CSS pixels
	// and compute a size needed to make our drawingbuffer match it in
	// device pixels.
	var displayWidth  = Math.floor(gl.canvas.clientWidth  * realToCSSPixels);
	var displayHeight = Math.floor(gl.canvas.clientHeight * realToCSSPixels);

	// Check if the canvas is not the same size.
	if (gl.canvas.width  != displayWidth || gl.canvas.height != displayHeight) {

		// Make the canvas the same size
		gl.canvas.width  = displayWidth;
		gl.canvas.height = displayHeight;

		// Set the viewport to match
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	}

	xres = displayWidth;
	yres = displayHeight;
}


function updateFPS(){

	var now = new Date().getTime();	

	frameCount++;
	elapsedTime += (now - lastTime);

	lastTime = now;

	if(elapsedTime >= 1000) {
		fps = frameCount;
		frameCount = 0;
		elapsedTime -= 1000;
}

document.getElementById('hud').innerHTML = "FPS: " + fps;
}

</script>


</head>

<body onload="initWebGL()">
<canvas id="glcanvas"> 
Your browser does not support the HTML5 canvas element.
</canvas>

<div id="hud">
</div>
</body>
</html>
