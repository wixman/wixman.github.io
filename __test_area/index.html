<!doctype html>
<html><head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>Test Area</title>

<style>
	body{ background-color: #100806;
			}
			
	canvas{ background-color: #100806;
			position: absolute;
			z-index:1;
	}
	body, html { width: 100%;
		height: 100%;
		border: 0px;
		padding: 0px;
		margin: 0px;
		cursor: pointer;
		cursor: hand; 
	}

	#glcanvas {
		width: 100%;
		height: 100%;
		vertical-align: bottom;
		display: block;
	}

	#hud {
		position: absolute;
		margin: 0 auto;		
		z-index: 2;
		font-family: Helvetica,Arial,sans-serif;
		font-size:10px;
		font-weight:normal;
		line-height:15px; 
		color: #fff;
		right: 10px;
		bottom: 7px;}

</style>

<script src="./js/raf_polyfill.js"></script> <!-- request animation frame -->

<script>
// create global variables
var gl = null,
	canvas = null,
	glProgram = null,
	renderShader= null,
	timestepShader= null,
	vertexShader = null;
	vbo = null;

// for counter
var elapsedTime = 0;
var frameCount = 0; 
var lastTime = new Date().getTime();	
var fps = 59;

// for uniforms	
var startTime = null,
	currentTime = null,
	xres = null,
	yres = null;


function initWebGL()
{
	canvas = document.getElementById("glcanvas");  
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	try{
		// get our webgl context
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");					
	}catch(e){
	}
					
	if(gl){
		initShaders();

		var timestepProgram = createAndLinkProgram(gl, vertexShader, timestepShader);
		var renderProgram = createAndLinkProgram(gl, vertexShader, renderShader);

		//use program
		gl.useProgram(renderProgram);
		setupBuffers(gl, renderProgram);
		// uniforms
		renderProgram.timeUniform = gl.getUniformLocation(renderProgram, "iGlobalTime");
		renderProgram.resUniform = gl.getUniformLocation(renderProgram, "iResolution");
		gl.uniform3f(renderProgram.resUniform, xres, yres, 0.0);
		gl.uniform1f(renderProgram.timeUniform, currentTime);
		
		//use program
		gl.useProgram(timestepProgram);
		setupBuffers(gl, timestepProgram);
		// uniforms
		renderProgram.timeUniform = gl.getUniformLocation(timestepProgram, "iGlobalTime");
		renderProgram.resUniform = gl.getUniformLocation(timestepProgram, "iResolution");
		gl.uniform3f(renderProgram.resUniform, xres, yres, 0.0);
		gl.uniform1f(renderProgram.timeUniform, currentTime);
		

		var initial_state = getInitialState(); // manually populate initial texture state

		var texture1 = newTexture(gl, initial_state), // create texture with initial state 
			framebuffer1 = newFramebuffer(gl, texture1),
			texture2 = newTexture(gl, null), // blank texture
			framebuffer2 = newFramebuffer(gl, texture2);


		startTime = Date.now();

		// MAIN LOOP
		(function animLoop() {
			currentTime = (Date.now() - startTime) / 1000;
			drawScene();
			gl.uniform3f(renderProgram.resUniform, xres, yres, 0.0);
			gl.uniform1f(renderProgram.timeUniform, currentTime);
			updateFPS();
			requestAnimationFrame(animLoop, canvas);
			resize(gl);
		} )();

	}

	
	else 
	{	
		alert( "Error: Your browser does not support WebGL." );
	}
}



function getInitialState() {
	var a = new Float32Array(4 * W * H);

	for (var y=0; y<H; y++) {
		for (var x=0; x<W; x++) {
			var i = W*y + x;
			var central_square = (x > W/2-10 && x < W/2 + 10 && y > H/2-10 && y < H/2+10);
			if (central_square) {
				a[4*i + 0] = 0.5 + Math.random() * 0.02 - 0.01;
				a[4*i + 1] = 0.25 + Math.random() * 0.02 - 0.01;
			} else {
				a[4*i + 0] = 1.0;
				a[4*i + 1] = 0;
			}
		}
	}

	return a;
}



// Create, initialise, and bind a new texture
function newTexture(gl, initial_state) {
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, initial_state);

	return texture;
}

function newFramebuffer(gl, texture) {
	var fb = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

	return fb;
}

function loadVertexData(gl, prog) {
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, 1,1 ]), gl.STATIC_DRAW);

	var a_position = gl.getAttribLocation(prog, "a_position");
	gl.enableVertexAttribArray(a_position);
	gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
}

function createAndLinkProgram(gl, vertex_shader, fragment_shader) {
	var prog = gl.createProgram();
	gl.attachShader(prog, vertex_shader);
	gl.attachShader(prog, fragment_shader);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		fail("Failed to link program: " + gl.getProgramInfoLog(prog));
	}
	return prog;
}

function createShader(gl, shader_type, shader_code_id) {
	var shader = gl.createShader(shader_type);
	gl.shaderSource(shader, document.getElementById(shader_code_id).text);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		var err = gl.getShaderInfoLog(shader);
		fail("Failed to compile shader: " + err);
	}
	return shader
}

function checkCompatibility(gl) {
	if (!gl) fail("WebGL is not supported");

	var float_texture_ext = gl.getExtension("OES_texture_float");
	if (!float_texture_ext) fail("Your browser does not support the WebGL extension OES_texture_float");
	window.float_texture_ext = float_texture_ext; // Hold onto it

	var max_texture_size = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	if (max_texture_size < 512) fail("Your browser only supports "+max_texture_size+"Ã—"+max_texture_size+" WebGL textures");
}

function fail(message) {
	var fail = document.createElement("p");
	fail.id = "fail";
	fail.appendChild(document.createTextNode(message));
	document.body.removeChild(document.getElementById("canvas"));
	document.body.appendChild(fail);
	throw message;
}

init();
</script><canvas id="canvas" width="512" height="512"></canvas>

<div id="rbutr-extension-is-installed"></div><div style="display: none;" class="rbutrInstalled"></div></body></html>
function initShaders()
{
	//get shader sources with XMLHttpRequestObject
	var fs_timestep_source = null,
		fs_render_source = null;
		vs_source = null;

	var xhr = new XMLHttpRequest();
	//synchronous request - false third parameter
	xhr.open('GET', './shaders/base.vs', false);
	//overriding the mime type is required 
	xhr.overrideMimeType('text/plain');
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			vs_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}  
	}

	xhr.open('GET', './shaders/render.fs', false); 
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			fs_render_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}
	}  

	xhr.open('GET', './shaders/timestep.fs', false); 
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			fs_timestep_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}
	}

	//compile shaders	
	vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
	timestepShader = makeShader(fs_render_source, gl.FRAGMENT_SHADER);
	renderShader = makeShader(fs_render_source, gl.FRAGMENT_SHADER);
}


function createAndLinkProgram(gl, vertex_shader, fragment_shader) 
{
	var prog = gl.createProgram();
	gl.attachShader(prog, vertex_shader);
	gl.attachShader(prog, fragment_shader);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		fail("Failed to link program: " + gl.getProgramInfoLog(prog));
	}
	return prog;
}


function makeShader(src, type)
{
	//compile the vertex shader
	var shader = gl.createShader(type);
	gl.shaderSource(shader, src);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
	}
	return shader;
}


function getUniforms(gl, glProgram)
{
	glProgram.timeUniform = gl.getUniformLocation(glProgram, "iGlobalTime");
	glProgram.resUniform = gl.getUniformLocation(glProgram, "iResolution");
}


function setUniforms(gl, glProgram)
{
	gl.uniform1f(glProgram.timeUniform, currentTime);
	gl.uniform3f(glProgram.resUniform, 0.0, 1.0, 0.0);
}


function setupBuffers(gl, glProgram)
{
	var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     
										1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
	vbo = gl.createBuffer();
	gl.bindBuffer( gl.ARRAY_BUFFER, vbo );
	gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );		    
}


function drawScene()
{
	gl.vertexAttribPointer( gl, 2, gl.FLOAT, false, 0, 0);
	gl.enableVertexAttribArray( gl );
	gl.drawArrays(gl.TRIANGLES, 0, 6);
}


function setUniforms(glProgram){
	gl.uniform1f(glProgram.timeUniform, currentTime);
}


function resize(gl) {
	var realToCSSPixels = window.devicePixelRatio || 1;

	// Lookup the size the browser is displaying the canvas in CSS pixels
	// and compute a size needed to make our drawingbuffer match it in
	// device pixels.
	var displayWidth  = Math.floor(gl.canvas.clientWidth  * realToCSSPixels);
	var displayHeight = Math.floor(gl.canvas.clientHeight * realToCSSPixels);

	// Check if the canvas is not the same size.
	if (gl.canvas.width  != displayWidth || gl.canvas.height != displayHeight) {

		// Make the canvas the same size
		gl.canvas.width  = displayWidth;
		gl.canvas.height = displayHeight;

		// Set the viewport to match
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	}

	xres = displayWidth;
	yres = displayHeight;
}


function updateFPS(){

	var now = new Date().getTime();	

	frameCount++;
	elapsedTime += (now - lastTime);

	lastTime = now;

	if(elapsedTime >= 1000) {
		fps = frameCount;
		frameCount = 0;
		elapsedTime -= 1000;
}

document.getElementById('hud').innerHTML = "FPS: " + fps;
}

</script>


</head>

<body onload="initWebGL()">
<canvas id="glcanvas"> 
Your browser does not support the HTML5 canvas element.
</canvas>

<div id="hud">
</div>
</body>
</html>
