<!doctype html>
<html><head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>Test Area</title>

<style>
	body{ background-color: #100806;
			}
			
	canvas{ background-color: #100806;
			position: absolute;
			z-index:1;
	}
	body, html { width: 100%;
		height: 100%;
		border: 0px;
		padding: 0px;
		margin: 0px;
		cursor: pointer;
		cursor: hand; 
	}

	#glcanvas {
		width: 100%;
		height: 100%;
		vertical-align: bottom;
		display: block;
	}

	#hud {
		position: absolute;
		margin: 0 auto;		
		z-index: 2;
		font-family: Helvetica,Arial,sans-serif;
		font-size:10px;
		font-weight:normal;
		line-height:15px; 
		color: #fff;
		right: 10px;
		bottom: 7px;}

</style>

<script src="./js/raf_polyfill.js"></script> <!-- request animation frame -->

<script>
// create global variables
var gl = null,
	canvas = null,
	glProgram = null,
	renderShader= null,
	timestepShader= null,
	vertexShader = null;
	vbo = null;

// for counter
var elapsedTime = 0;
var frameCount = 0; 
var lastTime = new Date().getTime();	
var fps = 59;

// for uniforms	
var startTime = null,
	currentTime = null,
	xres = null,
	yres = null;


function initWebGL()
{
	canvas = document.getElementById("glcanvas");  
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	try{
		// get our webgl context
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");					
	}catch(e){
	}
					
	if(gl){
		initShaders();

		var timestepProgram = createAndLinkProgram(gl, vertexShader, timestepShader);
		var renderProgram = createAndLinkProgram(gl, vertexShader, renderShader);

		//use program
		gl.useProgram(renderProgram);
		setupBuffers(gl, renderProgram);
		// uniforms
		renderProgram.timeUniform = gl.getUniformLocation(glProgram, "iGlobalTime");
		renderProgram.resUniform = gl.getUniformLocation(renderProgram, "iResolution");
		gl.uniform3f(renderProgram.resUniform, xres, yres, 0.0);
		gl.uniform1f(renderProgram.timeUniform, currentTime);
		
		
		
		getUniforms(gl, renderProgram);

		startTime = Date.now();

		// MAIN LOOP
		(function animLoop() {
			currentTime = (Date.now() - startTime) / 1000;
			drawScene();
			gl.uniform3f(renderProgram.resUniform, xres, yres, 0.0);
			gl.uniform1f(renderProgram.timeUniform, currentTime);
			updateFPS();
			requestAnimationFrame(animLoop, canvas);
			resize(gl);
		} )();

	}

	
	else 
	{	
		alert( "Error: Your browser does not support WebGL." );
	}
}


function initShaders()
{
	//get shader sources with XMLHttpRequestObject
	var fs_timestep_source = null,
		fs_render_source = null;
		vs_source = null;

	var xhr = new XMLHttpRequest();
	//synchronous request - false third parameter
	xhr.open('GET', './shaders/base.vs', false);
	//overriding the mime type is required 
	xhr.overrideMimeType('text/plain');
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			vs_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}  
	}

	xhr.open('GET', './shaders/render.fs', false); 
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			fs_render_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}
	}  

	xhr.open('GET', './shaders/timestep.fs', false); 
	xhr.send(null);

	if (xhr.readyState == xhr.DONE) {
		if(xhr.status === 200)
		{
			fs_timestep_source = xhr.responseText;
		} else {  
			console.error("Error: " + xhr.statusText);  
		}
	}

	//compile shaders	
	vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
	timestepShader = makeShader(fs_render_source, gl.FRAGMENT_SHADER);
	renderShader = makeShader(fs_render_source, gl.FRAGMENT_SHADER);
}


function createAndLinkProgram(gl, vertex_shader, fragment_shader) 
{
	var prog = gl.createProgram();
	gl.attachShader(prog, vertex_shader);
	gl.attachShader(prog, fragment_shader);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		fail("Failed to link program: " + gl.getProgramInfoLog(prog));
	}
	return prog;
}


function makeShader(src, type)
{
	//compile the vertex shader
	var shader = gl.createShader(type);
	gl.shaderSource(shader, src);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
	}
	return shader;
}


function getUniforms(gl, glProgram)
{
	glProgram.timeUniform = gl.getUniformLocation(glProgram, "iGlobalTime");
	glProgram.resUniform = gl.getUniformLocation(glProgram, "iResolution");
}


function setUniforms(gl, glProgram)
{
	gl.uniform1f(glProgram.timeUniform, currentTime);
	gl.uniform3f(glProgram.resUniform, 0.0, 1.0, 0.0);
}


function setupBuffers(gl, glProgram)
{
	var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     
										1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
	vbo = gl.createBuffer();
	gl.bindBuffer( gl.ARRAY_BUFFER, vbo );
	gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );		    
}


function drawScene()
{
	gl.vertexAttribPointer( gl, 2, gl.FLOAT, false, 0, 0);
	gl.enableVertexAttribArray( gl );
	gl.drawArrays(gl.TRIANGLES, 0, 6);
}


function setUniforms(glProgram){
	gl.uniform1f(glProgram.timeUniform, currentTime);
}


function resize(gl) {
	var realToCSSPixels = window.devicePixelRatio || 1;

	// Lookup the size the browser is displaying the canvas in CSS pixels
	// and compute a size needed to make our drawingbuffer match it in
	// device pixels.
	var displayWidth  = Math.floor(gl.canvas.clientWidth  * realToCSSPixels);
	var displayHeight = Math.floor(gl.canvas.clientHeight * realToCSSPixels);

	// Check if the canvas is not the same size.
	if (gl.canvas.width  != displayWidth || gl.canvas.height != displayHeight) {

		// Make the canvas the same size
		gl.canvas.width  = displayWidth;
		gl.canvas.height = displayHeight;

		// Set the viewport to match
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	}

	xres = displayWidth;
	yres = displayHeight;
}


function updateFPS(){

	var now = new Date().getTime();	

	frameCount++;
	elapsedTime += (now - lastTime);

	lastTime = now;

	if(elapsedTime >= 1000) {
		fps = frameCount;
		frameCount = 0;
		elapsedTime -= 1000;
}

document.getElementById('hud').innerHTML = "FPS: " + fps;
}

</script>


</head>

<body onload="initWebGL()">
<canvas id="glcanvas"> 
Your browser does not support the HTML5 canvas element.
</canvas>

<div id="hud">
</div>
</body>
</html>
