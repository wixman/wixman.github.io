<html>

<head>

<title>Basic Shader Setup</title>


<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<script type="text/javascript" src="./js/gl-matrix.js"></script> 


<script id="shader-vs" type="x-shader/x-vertex">
// VERTEX SHADER
    attribute vec3 aVertexPosition;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
// FRAGMENT SHADER
    precision mediump float;

    void main(void) {
        gl_FragColor = vec4(0.8, 0.3, 0.6, 1.0);
    }
</script>


<script type="text/javascript">

	// global variables
    var gl; // stores context object
	var mvMatrix = mat4.create(); // model view matrix
	var pMatrix = mat4.create(); // perspective projection matrix
    var triangleVertexPositionBuffer; // triangle vbo
    var squareVertexPositionBuffer; // square vbo
    var shaderProgram; // stores shader


	// get context 
    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl");
            gl.viewportWidth = canvas.width; // store width/height info in context object
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL");
        }
	}



	function loadFile(url, callback, gl, errorCallback) {
		// Set up an asynchronous request
		var request = new XMLHttpRequest();
		request.open('GET', url, true);

		// Hook the event that gets called as the request progresses
		request.onreadystatechange = function () {
			// If the request is "DONE" (completed or failed)
			if (request.readyState == 4) {
				// If we got HTTP status 200 (OK)
				if (request.status == 200) {
					callback(request.responseText, gl)
				} else { // Failed
					errorCallback(url);
				}
			}
		};

		request.send(null);    
	}

	function compileShader(shaderText, gl){
		console.log(shaderText);
	}

	// parse shader scripts - will be changed to support external scripts
    function getShader(gl, url, type) {
		
		var shaderText;
		var str;

		loadFile(url, compileShader(shaderText, gl), gl, function (url) {
			alert('Failed to download "' + url + '"');})

        var shader;
        if (type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX);
        } 

		else if (type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT);
        } 
		
		else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
	}





    function initShaders() {
        var vertexShader = getShader(gl, "shaders/base.vs", "x-shader/x-vertex");
        var fragmentShader = getShader(gl, "shaders/base.fs", "x-shader/x-fragment");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        gl.useProgram(shaderProgram);
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		// create uniforms
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    }


	// set uniforms
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


	function initBuffers() {
		triangleVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
		var vertices = [
			 0.0,  1.0,  0.0,
			-1.0, -1.0,  0.0,
			 1.0, -1.0,  0.0
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		triangleVertexPositionBuffer.itemSize = 3;
		triangleVertexPositionBuffer.numItems = 3;

		squareVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
		vertices = [
			 1.0,  1.0,  0.0,
			-1.0,  1.0,  0.0,
			 1.0, -1.0,  0.0,
			-1.0, -1.0,  0.0
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		squareVertexPositionBuffer.itemSize = 3;
		squareVertexPositionBuffer.numItems = 4;
	}



    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		// create perspective projection matrix
        mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);

		// create model view matrix
        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, mvMatrix, [-1.5, 0.0, -7.0]);

		// bind triangle buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 
				triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        setMatrixUniforms(); // update uniforms with new translation
		// draw triangle
        gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);


        mat4.translate(mvMatrix, mvMatrix, [3.0, 0.0, 0.0]);
		// bind square buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 
				squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        setMatrixUniforms(); // update uniforms with new translation
		// draw square
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);

	}


	function webGLStart() {
		var canvas = document.getElementById("glcanvas");
		initGL(canvas); // get context
		initShaders();
		initBuffers();

		gl.clearColor(0.0, 0.0, 0.0, 1.0);
		gl.enable(gl.DEPTH_TEST);

		drawScene();

	}

</script>





<body onload="webGLStart();">
    <canvas id="glcanvas" style="border: none;" width="500" height="500"></canvas>
</body>



</html>
